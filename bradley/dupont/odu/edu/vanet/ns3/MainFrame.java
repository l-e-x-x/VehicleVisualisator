/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * MainFrame.java
 *
 * Created on Jul 7, 2011, 1:59:26 PM
 */
package bradley.dupont.odu.edu.vanet.ns3;

import bradley.dupont.odu.edu.vanet.ns3.db.DBManager;
import bradley.dupont.odu.edu.vanet.ns3.dto.VehicleLocation;
import bradley.dupont.odu.edu.vanet.ns3.dto.highway.Highway;
import bradley.dupont.odu.edu.vanet.ns3.dto.highway.HighwayConnection;
import bradley.dupont.odu.edu.vanet.ns3.dto.highway.HighwayProject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.File;
import java.io.FileInputStream;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.UIManager;
import javax.swing.table.DefaultTableModel;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.annotations.XYTextAnnotation;
import org.jfree.chart.axis.ValueAxis;
import org.jfree.chart.labels.XYToolTipGenerator;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.xy.AbstractXYDataset;
import org.jfree.data.xy.DefaultXYDataset;
import org.jfree.data.xy.XYDataset;
import org.jfree.ui.TextAnchor;

/**
 *
 * @author bdupont
 */
public class MainFrame extends javax.swing.JFrame {

    //private JFreeChart chart;
    private JFreeChart prevChart;
    private DynamicXYDataset dataset;
    private AtomicInteger speedupFactor;
    final private AtomicBoolean paused;
    private Thread renderThread;
    File highwayDataFile = null;
  
    /** Creates new form MainFrame */
    public MainFrame() {
        speedupFactor = new AtomicInteger(1);
        paused = new AtomicBoolean(false);
        initChart();
        initComponents();

    }

    private void initChart() {
        dataset = new DynamicXYDataset();
        //chart = ChartFactory.createScatterPlot(null, "X", "Y", dataset, PlotOrientation.VERTICAL, false, true, false);
        //XYPlot plot = chart.getXYPlot();
        //plot.getRenderer().setBaseToolTipGenerator(new ToolTipGenerator());

        DefaultXYDataset xys = new DefaultXYDataset();
        prevChart = ChartFactory.createXYLineChart(null, "X", "Y", xys, PlotOrientation.VERTICAL, false, true, false);
        prevChart.getXYPlot().setDataset(1, dataset);
        XYLineAndShapeRenderer xylineandshaperenderer = new XYLineAndShapeRenderer();
        xylineandshaperenderer.setSeriesLinesVisible(0, false);
        xylineandshaperenderer.setSeriesShapesVisible(0, true);
        xylineandshaperenderer.setSeriesShape(0, new Rectangle2D.Double(-3, -3, 6, 6));
        xylineandshaperenderer.setSeriesPaint(0, Color.GREEN);
        prevChart.getXYPlot().setRenderer(1, xylineandshaperenderer);
        prevChart.getPlot().setBackgroundPaint(Color.BLACK);
       // updateChartRanges();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        startPauseButton = new javax.swing.JButton();
        resetButton = new javax.swing.JButton();
        stepButton = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        simTimeField = new javax.swing.JFormattedTextField();
        jSplitPane1 = new javax.swing.JSplitPane();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        previewPanel = new ChartPanel(prevChart);
        tablePanel = new javax.swing.JPanel();
        tableScrollPanel = new javax.swing.JScrollPane();
        locationTable = new javax.swing.JTable();
        jMenuBar1 = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        loadNewDataMenuItem = new javax.swing.JMenuItem();
        loadMessageDataMenuItem = new javax.swing.JMenuItem();
        loadHighwayDataMenuItem = new javax.swing.JMenuItem();
        toolsMenu = new javax.swing.JMenu();
        startMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Vehicle Viewer");

        jLabel1.setText("Vehicles:");

        startPauseButton.setText("Start");
        startPauseButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startPauseButtonActionPerformed(evt);
            }
        });

        resetButton.setText("Reset");
        resetButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetButtonActionPerformed(evt);
            }
        });

        stepButton.setText("Step");
        stepButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stepButtonActionPerformed(evt);
            }
        });

        jLabel2.setText("Simulation Time:");

        jLabel4.setText("sec");

        simTimeField.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter(new java.text.DecimalFormat("#0.00"))));
        simTimeField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                simTimeFieldActionPerformed(evt);
            }
        });

        jLabel3.setText("Messages");
        jSplitPane1.setRightComponent(jLabel3);

        jTable1.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Sim Time (Sec)", "Vehicle ID", "Vehicle Pos", "Message", "User Index"
            }
        ));
        jScrollPane1.setViewportView(jTable1);

        jSplitPane1.setRightComponent(jScrollPane1);

        javax.swing.GroupLayout previewPanelLayout = new javax.swing.GroupLayout(previewPanel);
        previewPanel.setLayout(previewPanelLayout);
        previewPanelLayout.setHorizontalGroup(
            previewPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 116, Short.MAX_VALUE)
        );
        previewPanelLayout.setVerticalGroup(
            previewPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 452, Short.MAX_VALUE)
        );

        jTabbedPane1.addTab("Visual", previewPanel);

        locationTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null},
                {null, null, null, null, null, null},
                {null, null, null, null, null, null},
                {null, null, null, null, null, null}
            },
            new String [] {
                "Vehicle ID", "Type ID", "Location", "Direction", "Velocity", "Acceleration"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        tableScrollPanel.setViewportView(locationTable);

        javax.swing.GroupLayout tablePanelLayout = new javax.swing.GroupLayout(tablePanel);
        tablePanel.setLayout(tablePanelLayout);
        tablePanelLayout.setHorizontalGroup(
            tablePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tableScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 116, Short.MAX_VALUE)
        );
        tablePanelLayout.setVerticalGroup(
            tablePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(tableScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 452, Short.MAX_VALUE)
        );

        jTabbedPane1.addTab("Tabular", tablePanel);

        jSplitPane1.setLeftComponent(jTabbedPane1);

        fileMenu.setText("File");

        loadNewDataMenuItem.setText("Load Vehicle Data");
        loadNewDataMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadNewDataMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(loadNewDataMenuItem);

        loadMessageDataMenuItem.setText("Load Message Data");
        loadMessageDataMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadMessageDataMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(loadMessageDataMenuItem);

        loadHighwayDataMenuItem.setText("Load Highway Data");
        loadHighwayDataMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                loadHighwayDataMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(loadHighwayDataMenuItem);

        jMenuBar1.add(fileMenu);

        toolsMenu.setText("Tools");

        startMenuItem.setText("Start");
        startMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startMenuItemActionPerformed(evt);
            }
        });
        toolsMenu.add(startMenuItem);

        jMenuBar1.add(toolsMenu);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(startPauseButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(resetButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(stepButton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(simTimeField, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel4))
                    .addComponent(jSplitPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(startPauseButton)
                    .addComponent(resetButton)
                    .addComponent(stepButton)
                    .addComponent(jLabel2)
                    .addComponent(jLabel4)
                    .addComponent(simTimeField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSplitPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 499, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void loadNewDataMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadNewDataMenuItemActionPerformed
        if (JOptionPane.showConfirmDialog(this, "This will clear any previous data.  Are you sure you want to continue?", "Clear Data?", JOptionPane.YES_NO_OPTION) == JOptionPane.NO_OPTION) {
            return;
        }

        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new File("."));
        int result = chooser.showOpenDialog(this);
        if (result != JFileChooser.APPROVE_OPTION) {
            return;
        }
        resetButtonActionPerformed(null);
        File selectedFile = chooser.getSelectedFile();
        DBManager.INSTANCE.loadVehicleData(selectedFile.getAbsolutePath());

       // updateChartRanges();

        JOptionPane.showMessageDialog(this, "Complete");
    }//GEN-LAST:event_loadNewDataMenuItemActionPerformed

    private void loadMessageDataMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadMessageDataMenuItemActionPerformed
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new File("."));
        int result = chooser.showOpenDialog(this);
        if (result != JFileChooser.APPROVE_OPTION) {
            return;
        }
        File selectedFile = chooser.getSelectedFile();
        DBManager.INSTANCE.loadMessageData(selectedFile.getAbsolutePath());

        JOptionPane.showMessageDialog(this, "Complete");
    }//GEN-LAST:event_loadMessageDataMenuItemActionPerformed

    private void startMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startMenuItemActionPerformed
        startRendering(null);
    }//GEN-LAST:event_startMenuItemActionPerformed

    private void startPauseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startPauseButtonActionPerformed
        if (renderThread == null) {
            paused.set(false);
            startRendering(null);
            startPauseButton.setText("Pause");
        } else {
            if (!paused.get()) {
                paused.set(true);
                startPauseButton.setText("Start");
            } else {
                startPauseButton.setText("Pause");
                synchronized (paused) {
                    paused.set(false);
                    paused.notify();
                }
            }
        }
    }//GEN-LAST:event_startPauseButtonActionPerformed

    private void resetButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetButtonActionPerformed
        if (renderThread != null) {
            paused.set(false);
            renderThread.interrupt();
            try {
                renderThread.join();
            } catch (Exception ex) {
            }
            renderThread = null;
            dataset.addPoints(Collections.EMPTY_LIST);
            dataset.afterBatch();
            simTimeField.setValue(0.0);
          //  updateChartRanges();
            startPauseButton.setText("Start");
            ((DefaultTableModel) locationTable.getModel()).setRowCount(0);
            //((ChartPanel) chartPanel).repaint();
        }
    }//GEN-LAST:event_resetButtonActionPerformed

    private void stepButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stepButtonActionPerformed
        paused.set(true);
        if (renderThread == null) {
            startRendering(null);
        } else {
            synchronized (paused) {
                paused.notify();
            }
        }
    }//GEN-LAST:event_stepButtonActionPerformed

    private void simTimeFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_simTimeFieldActionPerformed
        resetButtonActionPerformed(null);
        try {
            simTimeField.commitEdit();
        } catch (Exception ex) {
        }
        long value = (long) (((Number) simTimeField.getValue()).doubleValue() * 1000000000L);
        paused.set(true);
        startPauseButton.setText("Start");
        //startRendering(value);
    }//GEN-LAST:event_simTimeFieldActionPerformed

    private void loadHighwayDataMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_loadHighwayDataMenuItemActionPerformed
        JFileChooser chooser = new JFileChooser();
        if (highwayDataFile != null)
            chooser.setCurrentDirectory(highwayDataFile);
        else
            chooser.setCurrentDirectory(new File("."));
        int result = chooser.showOpenDialog(this);
        if (result != JFileChooser.APPROVE_OPTION) {
            return;
        }
        File selectedFile = chooser.getSelectedFile();
        highwayDataFile = selectedFile;
        try {
                /*Удаляем все аннотации (подписи), если они есть*/
            XYTextAnnotation xytextannotation = null;
            while (!prevChart.getXYPlot().getAnnotations().isEmpty())
                prevChart.getXYPlot().removeAnnotation((XYTextAnnotation)prevChart.getXYPlot().getAnnotations().get(0));
                /*парсим XML - создаем проект HighwayProject proj*/
            HighwayProject proj = (HighwayProject) HighwayProject.xs.fromXML(new FileInputStream(selectedFile));
            DefaultXYDataset xyd = (DefaultXYDataset) prevChart.getXYPlot().getDataset();

            Font roadAnnotationFont = new Font("SansSerif", 1, 8);
            Font laneAnnotationFont = new Font("SansSerif", 0, 7);
            while (xyd.getSeriesCount() != 0) // removing series
                xyd.removeSeries(xyd.getSeriesKey(0));

            int seriesCounter=0; // счетчик серий
            Random rand = new Random();

            for (Highway aHighway : proj.getHighways())
            {
                Color colorOfSameSeries=Color.getHSBColor(rand.nextFloat(), 0.5f+rand.nextFloat()/2f, 0.7f);
                double[][] series = new double[2][2];
                series[0][0] = aHighway.getStartX();
                series[1][0] = aHighway.getStartY();
                double changeX = 0.0;
                double changeY = 0.0;
                double direction = aHighway.getDirection();
                double distance = aHighway.getLength();
                if (anglesEqual(direction, 0)) {
                    changeX = distance;
                } else if (anglesEqual(direction, Math.PI / 2.0)) {
                    changeY = distance;
                } else if (anglesEqual(direction, Math.PI)) {
                    changeX = -distance;
                } else if (anglesEqual(direction, 3.0 * Math.PI / 2.0)) {
                    changeY = -distance;
                } else {
                    changeX = distance * Math.cos(direction);
                    changeY = distance * Math.sin(direction);
                }
                series[0][1] = aHighway.getStartX() + changeX;
                series[1][1] = aHighway.getStartY() + changeY;

                    /*Annotation add*/
                String annotationStr = "#" + aHighway.getHighwayId();
                double annotationX = aHighway.getStartX() + changeX/4;
                double annotationY = aHighway.getStartY() + changeY/4;
                xytextannotation = new XYTextAnnotation(annotationStr, annotationX,annotationY);
                xytextannotation.setPaint(Color.WHITE);
                xytextannotation.setBackgroundPaint(Color.BLACK);
                xytextannotation.setFont(roadAnnotationFont);
		xytextannotation.setTextAnchor(TextAnchor.HALF_ASCENT_LEFT);
		prevChart.getXYPlot().addAnnotation(xytextannotation);

                    /*Series add*/
                double highwayLaneWidth = aHighway.getLaneWidth();
                double highwayWidth = highwayLaneWidth*aHighway.getNumberOfLanes();
                double RotateXFactor = Math.cos(direction-Math.PI/2); // множитель поворота относительно X
                double RotateYFactor = Math.sin(direction-Math.PI/2); // множитель поворота относительно Y
                double highwayRightLaneXOffset = RotateXFactor*(highwayWidth/2-highwayLaneWidth/2);
                double highwayRightLaneYOffset = RotateYFactor*(highwayWidth/2-highwayLaneWidth/2);
                double[][] laneSeries = new double[2][2]; // создаем серию для первой полосы
                /* первая полоса смещена налево относительно центра
                   дороги на highwayRightLaneXOffset по X и
                             highwayRightLaneYOffset по Y
                   ниже - вычисление смещений точек начала и
                   конца первой полосы от центра дороги*/
                laneSeries[0][0] = series[0][0]-highwayRightLaneXOffset;
                laneSeries[0][1] = series[0][1]-highwayRightLaneXOffset;
                laneSeries[1][0] = series[1][0]-highwayRightLaneYOffset;
                laneSeries[1][1] = series[1][1]-highwayRightLaneYOffset;
                for (Integer laneCntr=0; laneCntr < aHighway.getNumberOfLanes(); laneCntr++)
                {
                    String laneAnnotationStr=annotationStr+":"+laneCntr.toString();
                    xyd.addSeries(laneAnnotationStr, laneSeries);
                    prevChart.getXYPlot().getRenderer().setSeriesPaint(seriesCounter, colorOfSameSeries);
                    prevChart.getXYPlot().getRenderer().setSeriesStroke(seriesCounter, new BasicStroke(2.3f));
                    seriesCounter++;

                    double[][] nextLaneSeries = new double[2][2]; // создаем серию для следующей полосы
                    /*следующая полоса смещена относительно предыдущей на 
                     RotateXFactor*highwayLaneWidth по X и
                     RotateYFactor*highwayLaneWidth по Y 
                     ниже - вычисление смещений точек начала и конца полосы*/
                    nextLaneSeries[0][0] = laneSeries[0][0]+RotateXFactor*highwayLaneWidth;
                    nextLaneSeries[0][1] = laneSeries[0][1]+RotateXFactor*highwayLaneWidth;
                    nextLaneSeries[1][0] = laneSeries[1][0]+RotateYFactor*highwayLaneWidth;
                    nextLaneSeries[1][1] = laneSeries[1][1]+RotateYFactor*highwayLaneWidth;
                    if (aHighway.getNumberOfLanes() == 1)
                        break; // если полоса одна - не добавляем подписи для номеров полос
                        /*добавление подписей номеров полос для дороги*/
                    double laneAnnotationX = laneSeries[0][0] + changeX/3;
                    double laneAnnotationY = laneSeries[1][0] + changeY/3;
                    xytextannotation = new XYTextAnnotation(laneAnnotationStr, laneAnnotationX,laneAnnotationY);
                    xytextannotation.setPaint(Color.WHITE);
                    xytextannotation.setBackgroundPaint(Color.BLACK);
                    xytextannotation.setFont(laneAnnotationFont);
                    xytextannotation.setTextAnchor(TextAnchor.HALF_ASCENT_LEFT);
                    prevChart.getXYPlot().addAnnotation(xytextannotation);
                    laneSeries=nextLaneSeries;
                }

                /*----- добавлено отображение связей между дорогами---*/
               // осторожно! быдлокод!!!
                double[][] connectionVisualViewData  = new double[2][2];
                connectionVisualViewData[0][0]=series[0][1];
                connectionVisualViewData[1][0]=series[1][1];
                if (aHighway.getFrontHighways() != null)
                {   // если есть присоединенные дороги спереди
                    for(HighwayConnection frontHighwayConnection : aHighway.getFrontHighways())
                    {   // для каждой присоединенной дороги спереди
                        for (Highway connectedHighway : proj.getHighways())
                        {   // ищем присоединенную дорогу по id
                           if (connectedHighway.getHighwayId() != frontHighwayConnection.getHighwayId())
                               continue;
                           connectionVisualViewData[0][1]=connectedHighway.getStartX();
                           connectionVisualViewData[1][1]=connectedHighway.getStartY();
                           break;
                        }
                        double[][] connectionDataAdd = new double[2][2];
                        connectionDataAdd[0][0]=connectionVisualViewData[0][0];
                        connectionDataAdd[0][1]=connectionVisualViewData[0][1];
                        connectionDataAdd[1][0]=connectionVisualViewData[1][0];
                        connectionDataAdd[1][1]=connectionVisualViewData[1][1];
                        xyd.addSeries("FrontConnection" + aHighway.getHighwayId(), connectionDataAdd);
                            /*Устанавливаем параметры отображения серии*/
                        prevChart.getXYPlot().getRenderer().setSeriesPaint(seriesCounter, colorOfSameSeries);
                        prevChart.getXYPlot().getRenderer().setSeriesStroke(seriesCounter, new BasicStroke(1f));
                        seriesCounter++;
                    }
                }
                
                if (aHighway.getLeftHighways() != null)
                {   // если есть присоединенные дороги слева
                    for(HighwayConnection leftHighwayConnection : aHighway.getLeftHighways())
                    {   // для каждой присоединенной дороги слева
                        for (Highway connectedHighway : proj.getHighways())
                        {   // ищем присоединенную дорогу по id
                           if (connectedHighway.getHighwayId() != leftHighwayConnection.getHighwayId())
                               continue;
                           connectionVisualViewData[0][1]=connectedHighway.getStartX();
                           connectionVisualViewData[1][1]=connectedHighway.getStartY();
                           break;
                        }
                        double[][] connectionDataAdd = new double[2][2];
                        connectionDataAdd[0][0]=connectionVisualViewData[0][0];
                        connectionDataAdd[0][1]=connectionVisualViewData[0][1];
                        connectionDataAdd[1][0]=connectionVisualViewData[1][0];
                        connectionDataAdd[1][1]=connectionVisualViewData[1][1];
                        xyd.addSeries("LeftConnection" + aHighway.getHighwayId(), connectionDataAdd);
                            /*Устанавливаем параметры отображения серии*/
                        prevChart.getXYPlot().getRenderer().setSeriesPaint(seriesCounter, colorOfSameSeries);
                        prevChart.getXYPlot().getRenderer().setSeriesStroke(seriesCounter, new BasicStroke(1f));
                        seriesCounter++;
                    }
                }

                if (aHighway.getRightHighways() != null)
                {   // если есть присоединенные дороги справа
                    for(HighwayConnection rightHighwayConnection : aHighway.getRightHighways())
                    {   // для каждой присоединенной дороги справа
                        for (Highway connectedHighway : proj.getHighways())
                        {   // ищем присоединенную дорогу по id
                           if (connectedHighway.getHighwayId() != rightHighwayConnection.getHighwayId())
                               continue;
                           connectionVisualViewData[0][1]=connectedHighway.getStartX();
                           connectionVisualViewData[1][1]=connectedHighway.getStartY();
                           break;
                        }
                        double[][] connectionDataAdd = new double[2][2];
                        connectionDataAdd[0][0]=connectionVisualViewData[0][0];
                        connectionDataAdd[0][1]=connectionVisualViewData[0][1];
                        connectionDataAdd[1][0]=connectionVisualViewData[1][0];
                        connectionDataAdd[1][1]=connectionVisualViewData[1][1];
                        xyd.addSeries("RightConnection" + aHighway.getHighwayId(), connectionVisualViewData);
                            /*Устанавливаем параметры отображения серии*/
                        prevChart.getXYPlot().getRenderer().setSeriesPaint(seriesCounter, colorOfSameSeries);
                        prevChart.getXYPlot().getRenderer().setSeriesStroke(seriesCounter, new BasicStroke(1f));
                        seriesCounter++;
                    }
                }
            }

        } catch (Exception ex) {
            JOptionPane.showMessageDialog(this, "Error occured! Check XML file!");
        }
    }//GEN-LAST:event_loadHighwayDataMenuItemActionPerformed

    double zeroOut(double numToZero) {
        if (Math.abs(numToZero) < 1e-8) {
            return 0.0;
        } else {
            return numToZero;
        }
    }

    boolean anglesEqual(double angle1, double angle2) {
        return zeroOut(Math.abs(angle1 - angle2)) == 0.0;
    }

    private void startRendering(Long time) {
        if (renderThread != null) {
            return;
        }
        try {

            ResultSet simTimeRs = DBManager.INSTANCE.getTimes(time);
            renderThread = new Thread(new RenderRunner(simTimeRs), "Rendering Thread");
            renderThread.setDaemon(true);
            renderThread.start();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    /*private void updateChartRanges() {
        if (DBManager.INSTANCE.getMaxX() == Double.NEGATIVE_INFINITY) {
            return;
        }
        XYPlot plot = chart.getXYPlot();
        ValueAxis axis = plot.getDomainAxis();
        double buffer = (DBManager.INSTANCE.getMaxX() - DBManager.INSTANCE.getMinX()) * 0.1;
        axis.setLowerBound(DBManager.INSTANCE.getMinX() - buffer);
        axis.setUpperBound(DBManager.INSTANCE.getMaxX() + buffer);
        axis = plot.getRangeAxis();
        buffer = (DBManager.INSTANCE.getMaxY() - DBManager.INSTANCE.getMinY()) * 0.1;
        axis.setLowerBound(DBManager.INSTANCE.getMinY() - buffer);
        axis.setUpperBound(DBManager.INSTANCE.getMaxY() + buffer);
    }
*/
    private class DynamicXYDataset extends AbstractXYDataset {

        private Map<Integer, Point2D.Double> vehicleToPoint = new HashMap<Integer, Point2D.Double>();
        private List<Integer> vehicleIndex = new ArrayList<Integer>();

        @Override
        public int getSeriesCount() {
            return 1;
        }

        @Override
        public Comparable getSeriesKey(int arg0) {
            return "Key";
        }

        public int getItemCount(int arg0) {
            return vehicleIndex.size();
        }

        public Number getX(int seriesIndex, int itemIndex) {
            return vehicleToPoint.get(vehicleIndex.get(itemIndex)).x;
        }

        public Number getY(int seriesIndex, int itemIndex) {
            return vehicleToPoint.get(vehicleIndex.get(itemIndex)).y;
        }

        public void addVehiclePoint(Integer vehId, Point2D.Double location) {
            if (vehicleToPoint.containsKey(vehId)) {
                vehicleIndex.add(vehId);
            }
            vehicleToPoint.put(vehId, location);
        }

        public void addPoints(List<VehicleLocation> vehiclePoints) {
            Set<Integer> currentIds = new HashSet<Integer>();
            for (VehicleLocation vehicleEntry : vehiclePoints) {
                if (vehicleToPoint.put(vehicleEntry.getVehicleId(), vehicleEntry.getLocation()) == null) {
                    vehicleIndex.add(vehicleEntry.getVehicleId());
                }
                currentIds.add(vehicleEntry.getVehicleId());
            }

            for (Iterator<Integer> vehIdItr = vehicleIndex.iterator(); vehIdItr.hasNext();) {
                Integer id = vehIdItr.next();
                if (!currentIds.contains(id)) {
                    vehIdItr.remove();
                    vehicleToPoint.remove(id);
                }
            }
        }

        public void afterBatch() {
            fireDatasetChanged();
        }
    }

    private class ToolTipGenerator implements XYToolTipGenerator {

        public String generateToolTip(XYDataset dataset, int series, int item) {
            DynamicXYDataset dset = (DynamicXYDataset) dataset;

            StringBuilder sb = new StringBuilder();
            Integer index = dset.vehicleIndex.get(item);
            Point2D.Double loc = dset.vehicleToPoint.get(index);
            sb.append(index).append(": ").append(loc.x).append(",").append(loc.y);
            return sb.toString();
        }
    }

    private class RenderRunner implements Runnable {

        private ResultSet simTimes;
        private long previousTime;

        private RenderRunner(ResultSet simTimes) {
            this.simTimes = simTimes;
            previousTime = Long.MIN_VALUE;
            try {
                if (simTimes.next()) {
                    previousTime = simTimes.getLong("sim_time");
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }

        public void run() {
            if (previousTime == Long.MIN_VALUE) {
                return;
            }
            try {
                DefaultTableModel model = (DefaultTableModel) locationTable.getModel();
                for (;;) {


                    List<VehicleLocation> locations = DBManager.INSTANCE.getVehiclesForTime(previousTime);
                    dataset.addPoints(locations);
                    java.awt.EventQueue.invokeLater(new Runnable() {

                        public void run() {
                            dataset.afterBatch();
                        }
                    });


                    model.setRowCount(0);
                    for (VehicleLocation location : locations) {
                        Object[] row = new Object[6];
                        row[0] = String.valueOf(location.getVehicleId());
                        row[1] = String.valueOf(location.getVehicleType());
                        row[2] = location.getLocation().x + "," + location.getLocation().y;
                        row[3] = String.valueOf(location.getDirection());
                        row[4] = String.valueOf(location.getVelocity());
                        row[5] = String.valueOf(location.getAcceleration());
                        model.addRow(row);
                    }

                 //   ((ChartPanel) chartPanel).repaint();

                    simTimeField.setValue(previousTime / 1000000000.0);

                    if (!simTimes.next()) {
                        break;
                    }


                    long currentTime = simTimes.getLong("sim_time");
                    long sleepTime = (currentTime - previousTime) / 1000000;
                    sleepTime = sleepTime / speedupFactor.longValue();
                    try {
                        Thread.sleep(sleepTime);
                    } catch (InterruptedException ex) {
                        return;
                    }

                    synchronized (paused) {
                        if (paused.get()) {
                            try {
                                paused.wait();
                            } catch (InterruptedException ex) {
                                return;
                            }
                        }
                    }

                    previousTime = currentTime;
                }
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        try {
            UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        java.awt.EventQueue.invokeLater(new Runnable() {

            public void run() {
                new MainFrame().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu fileMenu;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTable jTable1;
    private javax.swing.JMenuItem loadHighwayDataMenuItem;
    private javax.swing.JMenuItem loadMessageDataMenuItem;
    private javax.swing.JMenuItem loadNewDataMenuItem;
    private javax.swing.JTable locationTable;
    private javax.swing.JPanel previewPanel;
    private javax.swing.JButton resetButton;
    private javax.swing.JFormattedTextField simTimeField;
    private javax.swing.JMenuItem startMenuItem;
    private javax.swing.JButton startPauseButton;
    private javax.swing.JButton stepButton;
    private javax.swing.JPanel tablePanel;
    private javax.swing.JScrollPane tableScrollPanel;
    private javax.swing.JMenu toolsMenu;
    // End of variables declaration//GEN-END:variables
}
